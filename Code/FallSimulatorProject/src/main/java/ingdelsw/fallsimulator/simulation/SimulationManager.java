// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package ingdelsw.fallsimulator.simulation;

import java.util.Arrays;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import ingdelsw.fallsimulator.math.Point;
import ingdelsw.fallsimulator.math.curves.Curve;

import javafx.animation.AnimationTimer;

public class SimulationManager {
	
	private static final Logger logger = LogManager.getLogger(SimulationManager.class);

    private Mass mass; 
    private Curve curve;
    private Point[] points;
    private double[] slopes;
    private double[] times;
    
    private MassArrivalObserver observer;
    private long startTime; // animation start time in nanoseconds

    public SimulationManager(Curve curve) {
        mass = null;
        this.curve = curve;
        this.points = curve.calculatePoints();
    }
    
    //observer pattern implementation for MassArrivalObserver
    public void addMassArrivalObserver(MassArrivalObserver observer)
    {
    	this.observer = observer;
    }
    
    public void notifyMassArrivalObserver(boolean arrived)
    {
    	observer.onMassArrival(this, arrived);
    }

    public Curve getCurve() {
        return curve;
    }

    public void setMass(Mass mass) {
        this.mass = mass;
    }

    public Mass getMass() {
        return mass;
    }

    public Point[] getPoints() {
        return points;
    }
    
    public double getArrivalTime() {
    	return times[points.length - 1];
    }

    public void setSlopes(double[] slopes) {
        this.slopes = slopes;
    }
    
    //creates an array that associates to each point the time in which the mass passes on that point.
    public double[] calculateTimeParametrization(double g) {
        times = new double[points.length];
        times[0] = 0;
        times[1] = Double.MIN_VALUE;//initialization to avoid approximated integral to diverge to infinity
        
        double h1; //y difference between i point and start point
        double h2; //y difference between i+1 point and start point
        double v1; //velocity in i point
        double v2; //velocity in i+1 point
        double v1y; //y component of v1
        double v2y; //y component of v2
        double integrand; //function to be integrated
        double dy; //y difference between i point and i+1 point
        
        logger.info("parametrizzazione curva rispetto al tempo");
        
        for (int i = 2; i < points.length; i++) {
        	
        	h1 = points[i-1].getY() - curve.getStartPoint().getY();
        	
        	if(h1==0){ // ensure the integral doesn't diverge to infinity if y difference is so small that is approximated to 0
        		times[i] = times[i-1] + Double.MIN_VALUE;
        		continue;
        	}
        	
        	h2 = points[i].getY() - curve.getStartPoint().getY();
        	
        	//expressions for velocity due to conservation of energy
        	v1 = Math.sqrt(2*g*h1);
        	v2 = Math.sqrt(2*g*h2);
        	
        	//velocity scomposition on y component
        	v1y = v1*Math.abs(Math.sin(slopes[i-1]));
        	v2y = v2*Math.abs(Math.sin(slopes[i]));
        	
        	dy = (Math.abs(points[i].getY() - points[i-1].getY()));
        	integrand = ((1/v1y + 1/v2y)/2); //mean value for integrand 
        	times[i] = times[i-1] + integrand * dy; //finite increment added to previous calculated time
        	
        	logger.debug("h1 [{}] : {}",i, h1);
        	logger.debug("velocitÃ  [{}] : {}",i, v1y);
            logger.debug(" tempi [{}] : {}",i, times[i]);
        }
        return times;
    }
	
    //method for animating the fall of the mass
    public void startAnimation() {
    	
    	AnimationTimer timer; 
    	
    	double x0 = points[0].getX() - mass.getMassDiameter() / 2;
    	double y0 = points[0].getY() - mass.getMassDiameter() / 2;
    	
        mass.getIcon().relocate(x0, y0);

        startTime = 0;
        
        timer = new AnimationTimer() {
        	
        	//define timer behaviour 
        	@Override
        	public void handle(long now) {
        	    if (startTime == 0) 
        	        startTime = now; //initialize start time to current time

        	    double elapsedTime = (now - startTime) / 1_000_000_000.0; // time passed from start time in seconds

        	    // find closest index of times array using binary search
        	    int index = Arrays.binarySearch(times, elapsedTime);
        	    
        	    if (index < 0) {
        	        // If there is not an exact correspondence, `binarySearch` returns -(insertionIndex) - 1
        	        index = -index - 1; //get index of previous element respect to where the time would be in the ordered array
        	    }

        	    // arrival to end point handling for the mass to position exactly on end point
        	    if (index >= times.length - 1) {
        	        double newX = points[points.length - 1].getX() - mass.getMassDiameter() / 2;
        	        double newY = points[points.length - 1].getY() - mass.getMassDiameter() / 2;
        	        mass.getIcon().relocate(newX, newY);
        	        this.stop();
        	        notifyMassArrivalObserver(true);//arrived=true
        	        return;
        	    }

        	    // handling for the case in which the mass reach a point with the same y of start point, so it needs to stop on that point
        	    if (index < times.length - 2 && points[index + 2].getY() < points[0].getY()) {
        	        mass.getIcon().relocate(points[index].getX() - mass.getMassDiameter() / 2,
        	                                points[index].getY() - mass.getMassDiameter() / 2);
        	        this.stop();
        	        notifyMassArrivalObserver(false);//arrived=false
        	        return;
        	    }

        	    // calculate mean position between points[index] and points[index + 1] weighted respect to proximity of elapsed time to times[index] and times[index+1]
        	    double ratio = (elapsedTime - times[index]) / (times[index + 1] - times[index]);
        	    double x = points[index].getX() + (points[index + 1].getX() - points[index].getX()) * ratio - mass.getMassDiameter() / 2;
        	    double y = points[index].getY() + (points[index + 1].getY() - points[index].getY()) * ratio - mass.getMassDiameter() / 2;

        	    // set mass position
        	    mass.getIcon().relocate(x, y);
        	}

        };

        // start AnimationTimer
        timer.start();
    }
}