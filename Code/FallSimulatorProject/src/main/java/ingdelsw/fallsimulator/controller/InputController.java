// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package ingdelsw.fallsimulator.controller;

import java.util.ArrayList;
import java.util.List;

//logging support
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import ingdelsw.fallsimulator.math.Point;

//javaFX alert buttons
import javafx.scene.control.Alert;
import javafx.scene.control.ButtonType;
import javafx.scene.control.Alert.AlertType;

public class InputController {
	
	//log4j logger
	private static final Logger logger = LogManager.getLogger(InputController.class);
	
	//input fields
    private Point startPoint;
    private Point  endPoint;
    private List<Point> intermediatePoints;
    
    //singleton instance
    private static InputController theController = null;
    
    private InputController() {
    	startPoint = null;
    	endPoint = null;
        intermediatePoints = new ArrayList<>();
    }
    
    
    //Singleton pattern implementation
    public static InputController getController()
    {
    	if(theController == null)
    		theController = new InputController();
    	return theController;
    }
    
    public static void resetInstance() {
        theController = null;
    }
    
    //inputs getters
    public Point getStartPoint() {
        return startPoint;
    }
    
    public Point getEndPoint() {
    	return endPoint;
    }
    
    public List<Point> getIntermediatePoint() {
    	return intermediatePoints;
    }
    
    //input setters with controls
    public void setStartpoint(Point startPoint) {
        this.startPoint = startPoint;
        logger.debug("startPoint : X : {}  Y : {}", startPoint.getX(), startPoint.getY());
    }
    
    //end point setter 
    public void setEndpoint(Point endPoint) {
    	if(endPoint.getY()<=startPoint.getY())//end point is lower than the start point
    		throw new IllegalArgumentException("Il punto di arrivo deve essere piÃ¹ in basso di quello di partenza");
    	else if(endPoint.getX() == startPoint.getX())//end point and start point on the same vertical
    		this.endPoint = new Point(endPoint.getX() + 1, endPoint.getY()); //push end point by one pixel
    	else {
    		this.endPoint=endPoint;
    	}
    	logger.debug("startPoint : X : {}  Y : {}", endPoint.getX(), endPoint.getY());
    }
    
    //intermediate points setter that adds intermediate points for the cubic spline and controls that they are orizzontally between startpoint and endpoint
    public void addIntermediatePoint(Point p) {
    	for(int i = 0; i<intermediatePoints.size(); i++)
    	{
    		if(intermediatePoints.get(i).getX() == p.getX())//intermediate points can't be on the same vertical
    			p.setX(p.getX()+1);//push intermediate point point by one pixel
    	}
    	
    	if(endPoint.getX() <= p.getX() && startPoint.getX() <= p.getX() || endPoint.getX() >= p.getX() && startPoint.getX() >= p.getX()) //intermediate point is not orizzontally between startpoint and endpoint
    		throw new IllegalArgumentException("I punti intermedi devono essere compresi tra il punto di partenza e il punto di arrivo");
    	else{
    		intermediatePoints.add(p);
    		logger.debug("intermediatePoint : X : {}  Y : {}", p.getX(), p.getY());
    	}
    }
    
    public void handleException(Exception e) {
        // show an error window with a message when an exception is catch
        Alert alert = new Alert(AlertType.ERROR, e.getMessage(), ButtonType.OK);
        alert.showAndWait();
    }
    
    //delete intermediate points
    public void clearIntermediatePoints() {
        intermediatePoints.clear();
    }
    
    //delete inputs
    public void clearInput() {
        startPoint=null;
        endPoint=null;
        clearIntermediatePoints();
    }
}
