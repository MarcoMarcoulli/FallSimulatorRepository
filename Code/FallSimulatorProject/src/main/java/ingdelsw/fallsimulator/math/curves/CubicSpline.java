// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package ingdelsw.fallsimulator.math.curves;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

import org.apache.commons.math3.analysis.interpolation.SplineInterpolator;
import org.apache.commons.math3.analysis.polynomials.PolynomialSplineFunction;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import ingdelsw.fallsimulator.math.Point;

public class CubicSpline extends Curve {
	
	private static final Logger logger = LogManager.getLogger(CubicSpline.class);
	
	private PolynomialSplineFunction splineFunction;  // spline function
	private Point[] interpolationPoints;  // control points array
	
	public CubicSpline(Point startPoint, Point endPoint, List<Point> intermediatePoints) {
        super(startPoint, endPoint);

        int n = intermediatePoints.size() + 2; //#control points + start point + end point
    	interpolationPoints = new Point[n];
    	interpolationPoints[0] = startPoint;
    	for(int i = 1; i < n-1; i++)
    	{
    		interpolationPoints[i] = intermediatePoints.get(i-1);
    	}
    	interpolationPoints[n-1] = endPoint;
    	
    	Arrays.sort(interpolationPoints, Comparator.comparingDouble(Point::getX));
    	
    	double[] x = new double[n];
    	double[] y = new double[n];

    	for(int i=0; i < n; i++)
    	{
    		x[i] = interpolationPoints[i].getX();
    		y[i] = interpolationPoints[i].getY();
    	}
    	
        //creates cubic spline interpolating function with Apache Commons Math
    	if(interpolationPoints.length>2) {
    		SplineInterpolator interpolator = new SplineInterpolator();
    		splineFunction = interpolator.interpolate(x, y);
    	}
    	else{
    		splineFunction = null;
    	}
    }
 
 	// method for evaluating spline y on a point x
    public double evaluateY(double x) {
    	//linear segment between startPoint and endPoint
    	if(splineFunction == null)
    	{
    		double m = intervalY / intervalX;
    		return m * (x - startPoint.getX()) + startPoint.getY();
    	}
    	//spline function evaluation
    	else return splineFunction.value(x);
    }
    
    public Point[] calculatePoints()
    {
    	Point[] points = new Point[NUMPOINTS];
    	double x;
    	double y;
    	double t;
    	double xCubic;
    	logger.info("calcolo punti spline");
    	for (int i=0; i < NUMPOINTS-1 ; i++) {
    		t = (double) i / (NUMPOINTS - 1); 
            xCubic = intervalX * Math.pow(t, 3);    
            x = startPoint.getX() + xCubic;
    		y = evaluateY(x);
    		points[i] = new Point(x, y);
    		logger.debug("Punto[{}]: x = {}, y = {}", i, x, y);
        }
    	points[NUMPOINTS-1]= endPoint;
    	return points;
    }
    
    public double[] calculateSlopes()
    {
    	double[] slopes = new double[NUMPOINTS];
    	if(splineFunction == null)
    	{
    		logger.info("calcolo pendenza segmento lineare");
    		double m = intervalY / intervalX;
    		for(int i=0; i < NUMPOINTS; i++)
    		{	
    			slopes[i] = Math.atan(m);
    		}
    		logger.debug("pendenza: {} ", (slopes[0] / Math.PI) * 180);
    		return slopes;
    	}
    	else {
    		double x;
    		double  t;
    		double  xCubic;
    		logger.info("calcolo pendenze spline");
	    	for (int i=0; i < NUMPOINTS - 1; i++) {
	    		t = (double) i / (NUMPOINTS - 1); 
                xCubic = intervalX * Math.pow(t, 3);
                x = startPoint.getX() + xCubic;
	            slopes[i] = Math.atan(splineFunction.derivative().value(x));
	            logger.debug("pendenza[{}]: {} ", i, (slopes[i] / Math.PI) * 180);
	    	}
	    	slopes[NUMPOINTS-1] = slopes[NUMPOINTS-2];
	    	return slopes;
    	}
    }
    
    public String curveName()
	{
		return "spline";
	}
}
