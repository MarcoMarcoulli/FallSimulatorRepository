// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package ingdelsw.fallsimulator.math.curves;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import ingdelsw.fallsimulator.math.Point;

public class Circle extends Curve {
	
	private static final Logger logger = LogManager.getLogger(Circle.class);
	
	private double r; //circle radius
	private int convexity; //circle convexity: 1->convexity up  -1->convexity down

    
    //initial circle constructor
    public Circle(Point startPoint, Point endPoint, int convexity) {
    	super(startPoint, endPoint);
        this.convexity=convexity;
        if(convexity == -1) {//convexity down
        	//radius for orizontal tangent in start point
        	this.r = (Math.pow(intervalX, 2)+Math.pow(intervalY, 2))/(2 * intervalY) + 1;
        }
        //convexity up
        //radius for vertical tangent in start point
        else this.r = (Math.pow(intervalX, 2)+Math.pow(intervalY, 2))/(2 * intervalX); 
    }
    
    //selected radius circle constructor
    public Circle(Point startPoint, Point endPoint, int convexity, double r) {
    	super(startPoint, endPoint);
    	this.r = r;
        this.convexity = convexity;
    }
    
    
    public double getR()
    {
    	return r;
    }
    
    //function for a circle passing from the origin
    public double evaluateFunction(double variable) {
    	return Math.sqrt(2*variable*r - Math.pow(variable, 2));
    }
    
    @Override
    public Point[] calculatePoints() {
    	Point[] points = new Point[NUMPOINTS];//array for the points 
    	
    	//absolute coordinates of the center
    	double xCenter = xCenter() + startPoint.getX();
    	double yCenter = yCenter() + startPoint.getY();
    	double x;
    	double y;
    	
    	if(convexity == 1)
    	{
    		double t;
    		double xCubic;
    		double x0 = xCenter - r;
    		logger.info("calcolo punti circonferenza con concavità verso l'alto");
        	for (int i=0; i < NUMPOINTS; i++) {
        		t = (double) i / (NUMPOINTS - 1); // index normalized respect to numpoints
        		//more points density at the beginning with a cubic relation
        		xCubic = intervalX * Math.pow(t, 3);
        		x = startPoint.getX() + xCubic;
                y = yCenter + evaluateFunction(x - x0);
                points[i] = new Point(x,y);
                logger.debug("Punto[{}]: x = {}, y = {}", i, x, y);
            }
    	}
    	
    	else if(convexity == -1)
    	{
    		double t;
    		double  yCubic;
    		double y0 = yCenter - r;
    		logger.info("calcolo punti circonferenza con concavità verso il basso");
        	for (int i=0; i < NUMPOINTS; i++) {
        		t = (double) i / (NUMPOINTS - 1);
                yCubic = intervalY * Math.pow(t, 3); 
        		y = startPoint.getY() + yCubic;
                x = xCenter + Math.signum(intervalX)*evaluateFunction(y -y0);
                points[i] = new Point(x,y);
                logger.debug("Punto[{}]: x = {}, y = {}", i, x, y);
            }
    	}
    	return points;
    }
    
    //second order equation coefficients
    private double aCoefficient(){
    	return Math.pow(intervalX, 2) + Math.pow(intervalY, 2);
    }
    
    private double bCoefficient(){
    	return -intervalX*aCoefficient();
    }
    
    private double cCoefficient(){
    	return Math.pow(aCoefficient()/2, 2) - Math.pow(intervalY*r, 2);
    }
    
    //calculates center relative X coordinate
    private double xCenter(){	
    	double xCenter;
    	xCenter = intervalX/2 + convexity*Math.signum(intervalX) * Math.sqrt(Math.pow(intervalX/2,2)-cCoefficient()/aCoefficient());
    	logger.debug(" yCenter : {}", xCenter);
    	return xCenter;
    }
    
    //calculates center relative Y coordinate
    private double yCenter(){
    	double yCenter = (Math.pow(intervalX, 2) + Math.pow(intervalY, 2) - 2*xCenter()*intervalX)/(2*intervalY);
    	logger.debug(" yCenter : {}", yCenter);
    	return yCenter;
    } 
    
    @Override
    public double[] calculateSlopes(){
    	double[] slopes = new double[NUMPOINTS];
    	
    	//absolute coordinates of the center
    	double xCenter = xCenter() + startPoint.getX();
    	double yCenter = yCenter() + startPoint.getY();
    	
    	if(convexity == 1)
    	{
    		double t;
    		double xCubic;
    		double x;
    		double x0 = xCenter-r;
    		logger.info("calcolo pendenze circonferenza con concavità verso l'alto");
        	for (int i=0; i < NUMPOINTS; i++) {
        		t = (double) i / (NUMPOINTS - 1); 
                xCubic = intervalX * Math.pow(t, 3);    
                x = startPoint.getX() + xCubic;
                //circumference derivative
                slopes[i] = Math.atan((r-(x-x0))/Math.sqrt(2*r*(x-x0) - Math.pow(x-x0, 2))); 
                logger.debug("pendenza[{}]: {} ", i, (slopes[i] / Math.PI) * 180);
            }
    	}
    	
    	else if(convexity == -1)
    	{
    		double t;
    		double yCubic;
    		double y;
    		double y0 = yCenter-r;
    		logger.info("calcolo pendenze circonferenza con concavità verso il basso");
        	for (int i=0; i < NUMPOINTS; i++) {
        		t = (double) i / (NUMPOINTS - 1);
                yCubic = intervalY * Math.pow(t, 3);
                y = startPoint.getY() + yCubic;
                //circle derivative
                slopes[i] = Math.PI/2 - Math.atan((r-(y-y0))/Math.sqrt(2*r*(y-y0) - Math.pow(y-y0, 2))); 
                logger.debug("pendenza[{}]: {} ", i, (slopes[i] / Math.PI) * 180);
            }
    	}
    	return slopes;
    }
    
    public String curveName(){
		return "circonferenza";
	}
}
