// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package ingdelsw.fallsimulator.math.curves;

import ingdelsw.fallsimulator.math.NonConvergenceException;
import ingdelsw.fallsimulator.math.Point;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class Cycloid extends Curve {
	
    private static final Logger logger = LogManager.getLogger(Cycloid.class);

    private double alfa; //parameter for the end point
    private double r; // radius of the generator circle

    public Cycloid(Point startPoint, Point endPoint) throws NonConvergenceException {
        super(startPoint, endPoint);
        alfa = calculateAlfa(intervalX, intervalY);
        r = calculateR(intervalY);
    }

    private double f(double a, double x, double y) {
        return ((a - Math.sin(a)) / (1 - Math.cos(a))) - (x / y);
    }
     
    private double df(double a) {
        double numerator = Math.pow(Math.sin(a), 2) - a * Math.sin(a);
        double denominator = Math.pow(1 - Math.cos(a), 2);
        return 1 + numerator / denominator;
    }

    // Newton-Raphson method for finding t
    private double calculateAlfa(double x, double y) throws NonConvergenceException {
        double alfaLocal = 4 * Math.atan(x / (2 * y)); // good initial approximation
        int maxIterations = 100;
        for (int i = 0; i < maxIterations; i++) {
            double fAlfa = f(alfaLocal, x, y);
            double dfAlfa = df(alfaLocal);
            double alfaNew = alfaLocal - fAlfa / dfAlfa;

            //method convergence control
            if (Math.abs(alfaNew - alfaLocal) < 1e-6) {
                logger.info("Convergenza raggiunta: alfa = {}", alfaNew);
                return alfaNew; // return value when it is near enough
            }
            alfaLocal = alfaNew;
        }
        logger.error("Il metodo di Newton-Raphson non converge dopo {} iterazioni", maxIterations);
        throw new NonConvergenceException(maxIterations);
    }

    private double calculateR(double y) {
        double rad = y / (1 - Math.cos(alfa));
        logger.debug("Raggio calcolato: {}", r);
        return rad;
    }

    public double evaluateX(double a) {
        return r * (a - Math.sin(a));
    }

    public double evaluateY(double a) {
        return r * (1 - Math.cos(a));
    }

    public Point[] calculatePoints() {
        Point[] points = new Point[NUMPOINTS];
        double t;
        double aPow;
        double x;
        double y;
        logger.info("calcolo punti cicloide");
        for (int i = 0; i < NUMPOINTS; i++) {
            t = (double) i / (NUMPOINTS - 1);
            aPow = alfa * Math.pow(t, 3);
            x = startPoint.getX() + evaluateX(aPow);
            y = startPoint.getY() + evaluateY(aPow);
            points[i] = new Point(x, y);
            logger.debug("Punto[{}]: x = {}, y = {}", i, x, y);
        }
        return points;
    }

    public double[] calculateSlopes() {
        double[] slopes = new double[NUMPOINTS];
        double t;
        double aPow;
        logger.info("calcolo pendenze cicloide");
        slopes[0] = Math.atan(Double.POSITIVE_INFINITY);
        logger.debug("pendenza[0]: {} ", (slopes[0] / Math.PI) * 180);
        for (int i = 1; i < NUMPOINTS; i++) {
            t = (double) i / (NUMPOINTS - 1);
            aPow = alfa * Math.pow(t, 3);
            slopes[i] = Math.atan(Math.sin(aPow) / (1 - Math.cos(aPow)));
            logger.debug("pendenza[{}]: {} ", i, (slopes[i] / Math.PI) * 180);
        }
        return slopes;
    }

    public String curveName() {
        return "cicloide";
    }
}
